<script setup lang="ts">
// Interface pour les items
interface Item {
  id: number;
  nomfichier: string;
  category: string;
  date: string;
  pathFull: string;
  zone: string;
  size: string;
}

const items = ref<Item[]>([]);
const dateFrom = ref<string | null>(null);
const dateTo = ref<string | null>(null);
const errorMessage = ref<string | null>(null);

const typeData = ref<'data' | 'log'>(localStorage.getItem('typeData') as 'data' | 'log' || 'data');
const typeClient = ref<'tipi' | 'tipi_client'>(localStorage.getItem('typeClient') as 'tipi' | 'tipi_client' || 'tipi');
const zone = ref<'zu' | 'za'>(localStorage.getItem('zone') as 'zu' | 'za' || 'za');

const isSelectionConfirmed = ref(false);
const showSelectionForm = ref(false);

// Ref pour le compteur de taille
const sizeCounter = ref<HTMLElement | null>(null);

const columns = [
  { checkbox: true, field: 'check' },
  { field: 'nomfichier', sortable: true, searchable: true, title: 'Nom fichier' },
  { field: 'size', sortable: true, searchable: false, title: 'Taille' },
  { field: 'category', sortable: true, filterControl: 'select', title: 'Catégorie' },
  { field: 'date', searchable: false, title: 'Date mise en ligne' },
];

function waitAnimation() {
  $("#loading-animation").show();
}

function hideWaitAnimation() {
  $("#loading-animation").hide();
}

const confirmSelection = () => {
  isSelectionConfirmed.value = true;
  showSelectionForm.value = false;
  localStorage.setItem('typeData', typeData.value);
  localStorage.setItem('typeClient', typeClient.value);
  localStorage.setItem('zone', zone.value);
  loadData();
};

const loadData = async () => {
  waitAnimation();
  try {
    const data: any[] = await $fetch(`/api/file/tipi/download/${typeData.value}/${zone.value}/listfile`);
    if (data.length > 0) {
      items.value = data.map((el) => ({
        ...el,
        date: new Intl.DateTimeFormat('fr-FR', {
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          timeZone: 'GMT',
        }).format(el.date),
        size: (parseInt(el.size, 10) / (1024 * 1024)).toFixed(2) + ' Mo'
      }));

      $('#table').bootstrapTable('destroy');
      $('#table').bootstrapTable({ columns: columns, data: items.value });
    }
  } catch (error: any) {
    errorMessage.value = 'Erreur lors de la récupération des données. Veuillez réessayer plus tard. ' + error.message;
  } finally {
    hideWaitAnimation();
  }
};

const applyDateFilter = () => {
  const table = $('#table');
  table.bootstrapTable('load', items.value);
  table.bootstrapTable(
    'filterBy',
    {},
    {
      filterAlgorithm: function (row: { date: string | number | Date; }, filters: any) {
        const day = row.date.toString().slice(0, 2);
        const month = row.date.toString().slice(3, 5) + '/';
        const year = row.date.toString().slice(6, 10);
        const itemDate = new Date(year + '/' + month + '/' + day);
        const fromDate = dateFrom.value ? new Date(dateFrom.value) : undefined;
        const toDate = dateTo.value ? new Date(dateTo.value) : undefined;

        if (fromDate && toDate) {
          return itemDate >= fromDate && itemDate <= toDate;
        } else if (!fromDate && toDate) {
          return itemDate <= toDate;
        } else if (fromDate && !toDate) {
          return itemDate >= fromDate;
        }

        return true;
      }
    }
  );
};

const calculateTotalSize = (selectedRows: any[]) => {
  return selectedRows.reduce((total, row) => {
    return total + parseFloat(row.size);
  }, 0);
};

const updateSizeCounter = () => {
  const selectedRows: any = $('#table').bootstrapTable('getSelections');
  const totalSize = calculateTotalSize(selectedRows);
  if (sizeCounter.value) {
    sizeCounter.value.innerText = `Total sélectionné : ${totalSize.toFixed(2)} Mo`;
  }
};

$('#table').on('check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table', updateSizeCounter);

const generateFile = async () => {
  waitAnimation();
  try {
    const selectedRows: any = $('#table').bootstrapTable('getSelections');
    if (selectedRows.length === 0) {
      alert('Veuillez sélectionner au moins un fichier.');
      return;
    }

    const totalSize = calculateTotalSize(selectedRows);
    if (totalSize > 200) {
      errorMessage.value = 'Limite de 200 Mo dépassée. Veuillez réduire la sélection.';
      return;
    }

    const filenames = selectedRows.map((row: any) => ({
      name: row.nomfichier,
      pathFull: row.pathFull,
      zone: row.zone
    }));

    const response = await fetch(`/api/file/tipi/download/${typeData.value}/download`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ filenames }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.statusMessage || 'Erreur lors du téléchargement des fichiers.');
    }

    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Fichiers_${typeData.value}_${zone.value}.zip`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    $('#table').bootstrapTable('uncheckAll');
  } catch (error: any) {
    console.error('Erreur lors de la génération du fichier ZIP:', error.message);
    errorMessage.value = 'Erreur lors de la génération du fichier ZIP. ' + error.message;
  } finally {
    hideWaitAnimation();
  }
};
</script>