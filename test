<template>
  <div class="bgg ">
    <div class="container ">
      <h1 class=" d-flex justify-content-center">Déposer des fichiers</h1>

      <div class="alert alert-danger  " role="alert" v-if="erreur">
        <p>{{ erreur }}</p>
      </div>
      <div class="row mt-4  d-flex justify-content-center ">
       
        <div class="col-md-6 ">
          <div class="card ">
            <div class="card-body border border-white ">
              <h5 class="card-title">Sélectionner les fichiers à déposer</h5>
              <div class="input-group input-test ">
                <input type="file" class="form-control" id="inputGroupFile01" multiple @change="uploadFiles"
                  accept=".jpg, .jpeg, .png,.doc,.docx,.xml,.pdf,.org,.csv,.sql,.txt,.tar.gz,.tar,.doc,.docx,.xls,.xlsx,.mp3,.mp4,html,.json," />
              </div>

              <div class="mt-3">
                <label for="categorySelect" class="form-label">Type de client </label>
              <select class="form-select" v-model="typeClient">
                  <option value="tipi">Tipi</option>
                  <option value="tipi_client">Tipi Client</option>
                </select>
              </div>

              <div class="mt-3">
                <label for="categorySelect" class="form-label">Zone</label>
                <select class="form-select" id="categorySelect"  v-model="zone">
                  <option value="zone">Sélectionner une zone</option>
                  <option value="za">ZA</option>
                  <option value="zu">ZU</option>
                </select>
              </div>
              
              <div class="mt-3">
                <label for="categorySelect" class="form-label">Choisir la catégorie :</label>
                <select class="form-select" id="categorySelect" v-model="selectedCategory">
                  <option value="">Sélectionner une catégorie</option>
                  <option v-for="category in categories" :value="category" :key="category">{{ category }}</option>
                </select>

              </div>
              <div class="d-flex justify-content-center ">
                <button class="btn mtj mt-3 " @click="uploadFiles">Déposer les fichiers</button>
              </div>
            </div>
          </div>
        </div>

        <div>
          <div class="card mt-3 border border-white" v-if="depositedFiles.length > 0">
            <div class="card-body ">
              <h3 class="card-title ">Fichiers déposés</h3>
              <div class="row mt-4 ">
                <div v-for="(file, index) in depositedFiles" :key="index" class="col-6 mb-3 ">
                  <div class="card h-100 file">
                    <div class="card-body">
                      <h6>
                        {{ file.name }}
                        <button class="btn btn-danger btn-sm" @click="removeFile(index)"> <i class="bi bi-trash"></i>
                        </button>

                      </h6>
                      <span class="badge bg-secondary">{{ file.category }}</span>

                    </div>
                  </div>
                </div>
              </div>

              <div class="d-flex justify-content-center">
                <button class="btn btn-success mt-3" @click="sendFilesToServer">Envoyer les fichiers</button>
              </div>

              <div class="mt-4">
                <div class="progress" role="progressbar" aria-label="Animated striped example" aria-valuenow="0"
                  aria-valuemin="0" aria-valuemax="100">
                  <div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 0%"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="mt-4" v-if="fileStatuses.length > 0">
            <h3>Statuts des fichiers envoyés</h3>
            <div class="alert alert-success  " role="alert" v-if="success">
              <p>{{ success }}</p>
            </div>
            <ul class="list-group">
              <li v-for="(status, index) in fileStatuses" :key="index"
                :class="{ 'list-group-item-success': status.success, 'list-group-item-danger': !status.success }"
                class="list-group-item d-flex justify-content-between align-items-center">

                {{ status.name }}
                <span v-if="status.success" class="badge bg-success">✔️</span>
                <span v-else class="badge bg-danger">❌ {{ status.error }}</span>
              </li>
            </ul>
          </div>
        </div>

      </div>


    </div>
  </div>
</template>
<script setup lang="ts">
type tStatus = { name: string; success: boolean; error?: string }
type tFile = { name: string; category: string; file: File }

const categories = ref<string[]>(["Catégorie 1", "Catégorie 2", "Catégorie 3"]);
const selectedCategory = ref<string>('');
const depositedFiles = ref<tFile[]>([]);
const fileStatuses = ref<tStatus[]>([]);
const erreur = ref()
const success = ref()
const zone = ref<'zu' | 'za'>(localStorage.getItem('zone') as 'zu' | 'za' || 'za');
const typeClient = ref<'tipi' | 'tipi_client'>(localStorage.getItem('typeClient') as 'tipi' | 'tipi_client' || 'tipi');

interface Item {
 
  category: string;

}

const uploadFiles = () => {
  if (selectedCategory.value === "") {
    erreur.value = "Veuillez sélectionner une catégorie."

    return;

  }
  erreur.value = ""
  fileStatuses.value = []; // Reset status
  const input = document.querySelector('input[type="file"]') as HTMLInputElement;
  const files = Array.from(input.files as FileList);
  if (files.length === 0) {
    erreur.value = "Veuillez sélectionner au moins un fichier."
    return;
  }
  erreur.value = ""

  console.log('ttt')
  files.forEach((file) => {
    depositedFiles.value.push({ name: file.name, category: selectedCategory.value, file });
  });

  input.value = "";
};

const removeFile = (index: number) => {
  depositedFiles.value.splice(index, 1);
};

const sendFilesToServer = async () => {
  const progressBar = document.querySelector(".progress-bar") as HTMLElement;
  fileStatuses.value = []; // Reset status

  let totalSize = 0;
  let uploadedSize = 0;

  depositedFiles.value.forEach((file: { file: { size: number; }; }) => {
    totalSize += file.file.size;
  });

  for (const file of depositedFiles.value) {
    const formData = new FormData();
    formData.append("file", file.file);

    try {
      const response = await fetch("/api/file/tipi/upload/depot", {
        method: "POST",
        body: formData,
      });

      const responseData = await response.json();

      if (!response.ok || !responseData.success) {
        throw new Error(responseData.message || 'Erreur inconnue');
      }

      uploadedSize += file.file.size;
      const progress = (uploadedSize / totalSize) * 100;
      progressBar.style.width = `${progress}%`;
      progressBar.setAttribute("aria-valuenow", progress.toString());

      fileStatuses.value.push({
        name: file.name,
        success: true,
      });
    } catch (error) {
      console.error("Erreur lors de l'envoi des fichiers:", error);
      fileStatuses.value.push({
        name: file.name,
        success: false,
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }

  //  une seconde pour s'assurer que la barre de progression atteint 100%
  setTimeout(() => {
    if (fileStatuses.value.every((status: { success: any; }) => status.success)) {
      success.value = "Fichiers envoyé avec succés"
    } else {
      erreur.value = "Certains fichiers n'ont pas été envoyés correctement"
    }

    depositedFiles.value = [];
    progressBar.style.width = '0%'; // Réinitialiser la barre de progression
  }, 1000); // Délai de 1 seconde avant d'afficher l'alerte
};



</script>


<style scoped>
.card-body h6 {
  display: flex;

  justify-content: space-between;
  align-items: center;
}

/*.card-body h6 button {
  margin-left: 10px;
} */

.badge {
  font-size: 12px;
  padding: 5px 10px;
  border-radius: 50px;
  background-color: #337ab7;
  color: #fff;
}
</style>
depot.ts
import fs from 'fs';
import path from 'path';
import { SFTPClient } from '~/services/sftp.service';
import { fileOut } from '~/services/files';

export default defineEventHandler(async (event) => {
  const formData = await readMultipartFormData(event);

  if (!formData || formData.length === 0) {
    return { message: 'Aucun fichier trouvé.', success: false, files: [] };
  }

  // Fonction pour générer un nom de dossier aléatoire de 6 caractères
  const generateRandomDirectoryName = () => {
    return Math.random().toString(36).substring(2, 8);
  };

  // Créer un répertoire temporaire avec un nom aléatoire
  const tempUploadDirectoryName = generateRandomDirectoryName();
  const uploadsDirectory = path.join(process.cwd(), 'tmp', 'uploads', tempUploadDirectoryName);

  const resultFiles: { name: string; success: boolean; error?: string; }[] = [];
  const sftp = new SFTPClient();

  try {
    await sftp.connect({ host: 'tpiiusa003' });

    // Créer le répertoire s'il n'existe pas
    try {
      if (!fs.existsSync(uploadsDirectory)) {
        fs.mkdirSync(uploadsDirectory, { recursive: true });
      }
    } catch (error) {
      const errorMessage = `Erreur lors de la création du répertoire de destination "${uploadsDirectory}".`;
      console.error(errorMessage, error);
      return { message: errorMessage, success: false, files: resultFiles };
    }

    // Gestion d'erreur
    try {
      for (const file of formData) {
        const remoteFilePath = `/tmp/${file.filename}`;
        const fileBuffer: Buffer = file.data;
        if (!file.filename) {
          const errorMessage = 'Le nom du fichier est indéfini.';
          console.error(errorMessage);
          resultFiles.push({ name: 'Indéfini', success: false, error: errorMessage });
          continue;
        }

        const filePath = path.join(uploadsDirectory, file.filename);

        try {
          fs.writeFileSync(filePath, fileBuffer);
          await sftp.uploadFile(filePath, remoteFilePath);
          resultFiles.push({ name: file.filename, success: true });
        } catch (error) {
          const errorMessage = `Erreur lors de l'enregistrement du fichier: ${file.filename}`;
          console.error(errorMessage, error);
          resultFiles.push({ name: file.filename, success: false, error: errorMessage });
        }
      }

      return { message: 'Fichiers traités.', success: true, files: resultFiles };
    } catch (error) {
      console.error('Erreur lors de l\'enregistrement des fichiers :', error);
      return { message: 'Erreur lors de l\'enregistrement des fichiers.', success: false, files: resultFiles };
    }
  } catch (error) {
    console.error('Erreur lors de la connexion SFTP:', error);
    throw createError({ statusCode: 500, statusMessage: 'Erreur lors de la connexion SFTP' });
  } finally {
    sftp.close();

    // Supprimer le répertoire temporaire des uploads
    try {
      fs.rmSync(uploadsDirectory, { recursive: true, force: true });
      console.log(`Répertoire temporaire supprimé : ${uploadsDirectory}`);
    } catch (error) {
      console.error(`Erreur lors de la suppression du répertoire temporaire : ${uploadsDirectory}`, error);
    }
  }
});

donload.vue 
<template>
  <div class="bgg">
    <div id="loading-animation">
      <div class="loader"></div>
    </div>
    <h1 class="text-center">Téléchargement de fichiers</h1>

    <!-- Formulaire de sélection -->
    <div v-if="!isSelectionConfirmed" class="p-4 mx-auto w-75 border border-white rounded-4">
      <h4 class="d-flex justify-content-center">Sélectionnez les options</h4>
      <div class="row justify-content-center">
        <div class="col-3">
          <label class="form-label mb-2 white">Type de données :</label>
          <select class="form-select" v-model="typeData">
            <option value="data">Données</option>
            <option value="log">Log</option>
          </select>
        </div>
        <div class="col-3">
          <label class="form-label mb-2 white">Environnement : </label>
          <select class="form-select" v-model="typeClient">
            <option value="tipi">Tipi</option>
            <option value="tipi_client">Tipi Client</option>
          </select>
        </div>
        <div class="col-3">
          <label class="form-label mb-2 white">Zone : </label>
          <select class="form-select" v-model="zone">
            <option value="za">ZA</option>
            <option value="zu">ZU</option>
          </select>
        </div>
        <div class="col-3 d-flex align-items-end">
          <button class="btn mtj" @click="confirmSelection">Valider</button>
        </div>
      </div>
    </div>

    <!-- Bouton pour afficher le formulaire de sélection -->
    <div v-if="isSelectionConfirmed" class="d-flex justify-content-center my-3">
      <button class="btn mtj" @click="showSelectionForm = true">Modifier la sélection</button>
    </div>

    <!-- Filtre de recherche et tableau -->
    <div v-if="isSelectionConfirmed" class="border border-white  shadow-lg rounded-3 p-4 my-3 mx-auto w-75">
      <h4 class="d-flex justify-content-center">Filtre de recherche <i class="bi bi-search ms-2"></i></h4>
      <div class="row justify-content-center">
        <div class="col-2">
          <label for="dateFrom" class="form-label mb-2 white">Date de début :</label>
          <input type="date" class="form-control" id="dateFrom" v-model="dateFrom" @change="applyDateFilter" />
        </div>
        <div class="col-2">
          <label for="dateTo" class="form-label mb-2 white">Date de fin :</label>
          <input type="date" class="form-control" id="dateTo" v-model="dateTo" @change="applyDateFilter" />
        </div>
        <div class="col-2">
          <label class="form-label mb-2 white">Nom du fichier :</label>
          <input type="text" id="customSearch" class="form-control form-control-simple" placeholder="rechercher" />
        </div>
        <div class="col-2" id="filter">
          <label class="select-label mb-2 white">Catégorie :</label>
          <select class="form-select bootstrap-table-filter-control-category">
            <option value="">Afficher tout</option>
          </select>
        </div>
      </div><br>
      <div v-if="errorMessage" class="alert alert-danger" role="alert">
        {{ errorMessage }}
      </div>
    </div>

    <div v-if="isSelectionConfirmed" class="w-75 m-auto my-3">
      <div :class="sizeClass"
        class="d-flex justify-content-center card border border-white p-2 my-2 mx-auto text-center sticky-top flex text-align">
        <p> <span class=" MO">(Limite de 200 Mo)</span> {{ animatedTotalSize }} Mo</p>
      </div>

      <table id="table" data-filter-control-container="#filter" data-toggle="table" data-pagination="true"
        data-search="true" data-filter-control="true" data-maintain-meta-data="true" data-click-to-select="true"
        data-search-highlight="true" data-search-selector="#customSearch"></table>

      <div v-if="parseFloat(totalSizeInMo) < 200" class="text-center mb-4 d-flex justify-content-center">
        <button class="btn mtj validerCouleur  sticky-bottom" @click="generateFile" type="button" data-dismiss="alert">
          Générer Fichiers
        </button>
      </div>
      <div v-else class="text-center mb-4 d-flex justify-content-center">
        <button class="btn mtj validerCouleur  sticky-bottom disabled" @click="generateFile" type="button" data-dismiss="alert">
          Générer Fichiers
        </button>
      </div>
    </div>

    <!-- Popup pour le formulaire de sélection -->
    <div v-if="showSelectionForm" class="modal" tabindex="-1" role="dialog" style="display: block;">
      <div class="modal-dialog" role="document">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Modifier la sélection</h5>
            <button type="button" class="btn-close " @click="showSelectionForm = false" aria-label="Close">
            </button>
          </div>
          <div class="modal-body">
            <div class="row justify-content-center">
              <div class="col-4">
                <label class="form-label mb-2 white">Type de données :</label>
                <select class="form-control" v-model="typeData">
                  <option value="data">Data</option>
                  <option value="log">Log</option>
                </select>
              </div>
              <div class="col-4">
                <label class="form-label mb-2 white">Type de client :</label>
                <select class="form-control" v-model="typeClient">
                  <option value="tipi">Tipi</option>
                  <option value="tipi_client">Tipi Client</option>
                </select>
              </div>
              <div class="col-4">
                <label class="form-label mb-2 white">Catégorie :</label>
                <select class="form-control" v-model="zone">
                  <option value="za">ZA</option>
                  <option value="zu">ZU</option>
                </select>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" @click="confirmSelection">Enregistrer</button>
            <button type="button" class="btn btn-secondary" @click="showSelectionForm = false">Fermer</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">

// Interface pour les items
interface Item {
  id: number;
  nomfichier: string;
  category: string;
  date: string;
  pathFull: string;
  zone: string;
  size: number;
}

const items = ref<Item[]>([]);
const selectedItems = ref<Item[]>([]);
const dateFrom = ref<string | null>(null);
const dateTo = ref<string | null>(null);
const errorMessage = ref<string | null>(null);

const typeData = ref<'data' | 'log'>(localStorage.getItem('typeData') as 'data' | 'log' || 'data');
const typeClient = ref<'tipi' | 'tipi_client'>(localStorage.getItem('typeClient') as 'tipi' | 'tipi_client' || 'tipi');
const zone = ref<'zu' | 'za'>(localStorage.getItem('zone') as 'zu' | 'za' || 'za');

const isSelectionConfirmed = ref(false);
const showSelectionForm = ref(false);
const currentSize = ref(0);
const animatedTotalSize = ref("0.00");

// Calcul du total en Mo
const totalSizeInMo = computed(() => {
  const total = selectedItems.value.reduce((total, item) => total + item.size, 0);
  return total.toFixed(2);
});

// Classe CSS dynamique pour la couleur du texte
const sizeClass = computed(() => {
  const total = parseFloat(totalSizeInMo.value);
  if (total < 150) {
    return 'text-success';
  } else if (total >= 150 && total < 200) {
    return 'text-warning';
  } else {
    return 'text-danger';
  }
});

// Animation du compteur
watch(totalSizeInMo, (newValue) => {
  const target = parseFloat(newValue);
  const step = (target - currentSize.value) / 23;
  const interval = setInterval(() => {
    currentSize.value += step;
    animatedTotalSize.value = currentSize.value.toFixed(2);
    if ((step > 0 && currentSize.value >= target) || (step < 0 && currentSize.value <= target)) {
      currentSize.value = target;
      animatedTotalSize.value = currentSize.value.toFixed(2);
      clearInterval(interval);
    }
  }, 20);
});

const columns = [
  { checkbox: true, field: 'check' },
  { field: 'nomfichier', sortable: true, searchable: true, title: 'Nom fichier' },
  { field: 'size', sortable: true, searchable: false, title: 'Taille (Mo)' },
  { field: 'category', sortable: true, filterControl: 'select', title: 'Catégorie' },
  { field: 'date', searchable: false, title: 'Date mise en ligne' },
];

function waitAnimation() {
  const loadingAnimation = document.getElementById("loading-animation");
  if (loadingAnimation) {
    loadingAnimation.style.display = "block";
  }
}

function hideWaitAnimation() {
  const loadingAnimation = document.getElementById("loading-animation");
  if (loadingAnimation) {
    loadingAnimation.style.display = "none";
  }
}

const confirmSelection = () => {
  isSelectionConfirmed.value = true;
  showSelectionForm.value = false;
  localStorage.setItem('typeData', typeData.value);
  localStorage.setItem('typeClient', typeClient.value);
  localStorage.setItem('zone', zone.value);
  loadData();
};

const loadData = async () => {
  waitAnimation();
  try {
    const data: any[] = await $fetch(`/api/file/tipi/download/${typeData.value}/${zone.value}/listfile`);
    if (data.length > 0) {
      items.value = data.map((el) => ({
        ...el,
        date: new Intl.DateTimeFormat('fr-FR', {
          year: 'numeric',
          month: 'numeric',
          day: 'numeric',
          hour: 'numeric',
          minute: 'numeric',
          second: 'numeric',
          timeZone: 'GMT',
        }).format(el.date),
        size: parseFloat((parseInt(el.size, 10) / (1024 * 1024)).toFixed(5)), // Convertir colonne size en Mo
      }));

      $('#table').bootstrapTable('destroy');
      $('#table').bootstrapTable({ columns: columns, data: items.value });

      // Ajouter les événements de mise à jour du compteur après le chargement des données
      $('#table').on('check.bs.table uncheck.bs.table check-all.bs.table uncheck-all.bs.table', updateSelectedItems);
    }
  } catch (error: any) {
    errorMessage.value = 'Erreur lors de la récupération des données. Veuillez réessayer plus tard. ' + error.message;
  } finally {
    hideWaitAnimation();
  }
};

const applyDateFilter = () => {
  const table = $('#table');
  table.bootstrapTable('load', items.value);
  table.bootstrapTable(
    'filterBy',
    {},
    {
      filterAlgorithm: function (row: { date: string | number | Date }, filters: any) {
        const day = row.date.toString().slice(0, 2);
        const month = row.date.toString().slice(3, 5) + '/';
        const year = row.date.toString().slice(6, 10);
        const itemDate = new Date(year + '/' + month + '/' + day);
        const fromDate = dateFrom.value ? new Date(dateFrom.value) : undefined;
        const toDate = dateTo.value ? new Date(dateTo.value) : undefined;

        if (fromDate && toDate) {
          return itemDate >= fromDate && itemDate <= toDate;
        } else if (!fromDate && toDate) {
          return itemDate <= toDate;
        } else if (fromDate && !toDate) {
          return itemDate >= fromDate;
        }

        return true;
      },
    }
  );
};

const updateSelectedItems = () => {
  const selectedRows: any = $('#table').bootstrapTable('getSelections');
  selectedItems.value = selectedRows.map((row: any) => ({
    ...row,
    size: parseFloat(row.size),
  }));
};

const generateFile = async () => {
  waitAnimation();
  try {
    const selectedRows: any = $('#table').bootstrapTable('getSelections');
    if (selectedRows.length === 0) {
      window.scroll(100, 0);
      errorMessage.value = 'Veuillez sélectionner au moins un fichier.';
      return;
    }

    const totalSize = selectedItems.value.reduce((total, item) => total + item.size, 0);
    if (totalSize > 200) {
      window.scroll(100, 0);
      errorMessage.value = 'Limite de 200 Mo dépassée. Veuillez réduire la sélection.';
      return;
    }

    const filenames = selectedRows.map((row: any) => ({
      name: row.nomfichier,
      pathFull: row.pathFull,
      zone: row.zone,
    }));

    const response = await fetch(`/api/file/tipi/download/${typeData.value}/download`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ filenames }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      throw new Error(errorData.statusMessage || 'Erreur lors du téléchargement des fichiers.');
    }

    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Fichiers_${typeData.value}_${zone.value}.zip`;
    document.body.appendChild(a);
    a.click();
    a.remove();
    $('#table').bootstrapTable('uncheckAll');
  } catch (error: any) {
    console.error('Erreur lors de la génération du fichier ZIP:', error.message);
    errorMessage.value = 'Erreur lors de la génération du fichier ZIP. ' + error.message;
  } finally {
    hideWaitAnimation();
  }
};
</script>

<style lang="scss" scoped>
// .tbl-filters {
//     // margin: 20px auto;
//     // padding: 20px;
//     // background-color: #ddd0c8;
//     // width: 70vw;
//     // border-radius: 10px;
//     // box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
// }

// .form-row {
//     margin-bottom: 20px;
// }

// .form-label {
//     margin-bottom: 10px;
// }

// .form-control {
//     height: calc(1.5em + 0.75rem + 2px);
//     // padding: 0.375rem 0.75rem;
//     font-size: 0.875rem;
//     line-height: 1.5;
// }

// .table {
//     background-color: rgb(231, 231, 231);
// }

// .filter-title {
//     color: rgb(0, 0, 0);
//     animation: slide-in 0.5s ease-in-out;

//     .bi-search {
//         margin-left: 5px;
//     }
// }

// h1 {
//     //     font-size: 32px;
//     //     font-family: Arial, Helvetica, sans-serif;
//     //     color: rgb(0, 0, 0);
//     //     padding: 16px;
//     //     font-weight: lighter;
//     //     box-shadow: 2px 2px 6px #9e9e9e;
//          text-align: center;
//     //     display: block;
//     //     border-radius: 20px;
// }

// .fixer {
//     position: fixed;

// }

// .bgg {
//     background-color: #ddd0c8;
//     min-height: 93.8vh;
//     margin: 0;
//     padding: 0;
// }</style>

download.ts 
import fs from 'fs';
import path from 'path';
import archiver from 'archiver';
import { SFTPClient } from '~/services/sftp.service';
import { generateRandomDirectoryName, removeDir } from '~/services/utils';
import { fileOut } from '~/services/files';

export default defineEventHandler(async (event) => {
    const env = getRouterParam(event, 'env') as string

    const body = await readBody(event); // Lire le corps de la requête pour obtenir la liste des noms de fichiers
    const { filenames } = body;

    console.log("Filenames reçus:", filenames); // Log des noms de fichiers reçus

    if (!Array.isArray(filenames) || filenames.length === 0) {
        console.error("Aucun fichier sélectionné ou format incorrect");
        throw createError({ statusCode: 400, statusMessage: 'Filenames nécessaire' });
    }


    // Créer des répertoires temporaires avec des noms aléatoires
    const tempUploadDirectoryName = generateRandomDirectoryName();
    const uploadDir = path.join(process.cwd(), 'tmp', 'uploads', tempUploadDirectoryName);

    const tempZipDirectoryName = generateRandomDirectoryName();
    const zipDir = path.join(process.cwd(), 'tmp', 'zipfiles', tempZipDirectoryName);
    const zipFilePath = path.join(zipDir, 'fichier.zip');

    // Créer les répertoires nécessaires s'ils n'existent pas
    try {
        if (!fs.existsSync(uploadDir)) {
            fs.mkdirSync(uploadDir, { recursive: true });
        }
        if (!fs.existsSync(zipDir)) {
            fs.mkdirSync(zipDir, { recursive: true });
        }
    } catch (error) {
        const errorMessage = `Erreur lors de la création des répertoires nécessaires.`;
        console.error(errorMessage, error);
        throw createError({ statusCode: 500, statusMessage: errorMessage });
    }


    const sftp = new SFTPClient();
    console.log("Création de l'archive...");
    // Créer un fichier pour diffuser les données de l'archive.
    const output = fs.createWriteStream(zipFilePath);
    const archive = archiver('zip', {
        zlib: { level: 9 } // Niveau de compression.
    });
    // Configure archiver pour écrire les données de l'archive dans le flux de sortie
    archive.pipe(output);

    try {
        for (const zone in fileOut) {
            const files = filenames.filter((el) => el.zone === zone.toUpperCase())
            if (files.length === 0)
                continue

            await sftp.connect({ host: fileOut[zone]?.server[env] || '' });

            for (const file of files) {
                const filePath = path.join(uploadDir, file.name);
                // const dst = fs.createWriteStream(filePath);
                await sftp.downloadFile(file.pathFull, filePath);

                if (fs.existsSync(filePath)) {
                    console.log(`Ajout du fichier: ${file.name}`);
                    archive.file(filePath, { name: file.name });
                    // dst.close();
                } else {
                    console.warn(`Fichier non trouvé: ${file.name}`);
                }
            }


            await sftp.close()
        }

        await archive.finalize();
        console.log("Archivage finalisé.");

        // Attendre que le flux de sortie soit fermé avant de lire le fichier ZIP
        await new Promise((resolve, reject) => {
            output.on('close', resolve);
            output.on('error', reject);
        });

        console.log("Lecture du fichier ZIP généré...");
        // Lire le fichier ZIP généré
        const zipFile = await fs.promises.readFile(zipFilePath);
        console.log("Fichier ZIP généré avec succès.");
        return zipFile; // Retourner directement le fichier ZIP

    } catch (error) {
        console.error('Erreur lors de la création du fichier ZIP:', error);
        throw createError({ statusCode: 500, statusMessage: 'Erreur lors de la création du fichier ZIP' });
    } finally {
        sftp.close();
        // Supprime le répertoire temporaires
        removeDir(uploadDir, { recursive: true, force: true });
        removeDir(zipDir, { recursive: true, force: true });
    }
})
